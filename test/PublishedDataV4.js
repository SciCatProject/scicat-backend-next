"use strict";
const utils = require("./LoginUtils");
const { TestData } = require("./TestData");
const sandbox = require("sinon").createSandbox();

let accessTokenArchiveManager = null,
  accessTokenAdminIngestor = null,

  idOrigDatablock = null,
  pid = null,
  pidnonpublic = null,
  attachmentId = null,
  doi = null;

const publishedData = { ...TestData.PublishedDataV4 };

const defaultStatus = "private";

const origDataBlock = { ...TestData.OrigDataBlockCorrect1 };

const modifiedPublishedData = {
  metadata: {
    ...TestData.PublishedDataV4.metadata,
    publisher: {
      name: "ESS",
      publisherIdentifierScheme: "testSchemeUpdated",
    },
  },
  abstract: "Published data generated by API test updated",
};

const testdataset = {
  ...TestData.RawCorrect,
  isPublished: true,
};

const nonpublictestdataset = {
  ...TestData.RawCorrect,
  ownerGroup: "examplenonpublicgroup",
};

describe("1600: PublishedDataV4: Test of access to published data v4 endpoints", () => {
  before(async () => {
    db.collection("Dataset").deleteMany({});
    db.collection("PublishedData").deleteMany({});

    accessTokenAdminIngestor = await utils.getToken(appUrl, {
      username: "adminIngestor",
      password: TestData.Accounts["adminIngestor"]["password"],
    });

    accessTokenArchiveManager = await utils.getToken(appUrl, {
      username: "archiveManager",
      password: TestData.Accounts["archiveManager"]["password"],
    });
  });

  afterEach((done) => {
    sandbox.restore();
    done();
  });

  it("0010: adds a new raw dataset", async () => {
    return request(appUrl)
      .post("/api/v3/Datasets")
      .send(testdataset)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.EntryCreatedStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        // store link to this dataset in datablocks
        pid = encodeURIComponent(res.body["pid"]);
        publishedData.datasetPids.push(res.body["pid"]);
        origDataBlock.datasetId = res.body["pid"];
        origDataBlock.ownerGroup = res.body.ownerGroup;
      });
  });

  it("0015: adds a published data", async () => {
    return request(appUrl)
      .post("/api/v4/PublishedData")
      .send(publishedData)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.EntryCreatedStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.property("title").and.be.string;
        res.body.should.have.property("metadata");
        res.body.metadata.should.have.property("publisher");
        res.body.should.have.property("status").and.equal(defaultStatus);
        doi = encodeURIComponent(res.body["doi"]);
      });
  });

  it("0020: should not be able to fetch this new published data in private state anonymously", async () => {
    return request(appUrl)
      .get("/api/v4/PublishedData/" + doi)
      .set("Accept", "application/json")
      .expect(TestData.NotFoundStatusCode);
  });

  it("0030: should fetch this new published data as admin ingestor", async () => {
    return request(appUrl)
      .get("/api/v4/PublishedData/" + doi)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.SuccessfulGetStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.property("metadata");
        res.body.metadata.publisher.should.have
          .property("name")
          .and.equal("ESS");
        res.body.should.have.property("status").and.equal(defaultStatus);
      });
  });

  it("0030: should be able to update this new published data as admin ingestor", async () => {
    return request(appUrl)
      .patch("/api/v4/PublishedData/" + doi)
      .send(modifiedPublishedData)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.SuccessfulGetStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.property("metadata");
        res.body.metadata.publisher.should.have
          .property("name")
          .and.equal("ESS");
        res.body.metadata.publisher.should.have
          .property("publisherIdentifierScheme")
          .and.equal("testSchemeUpdated");
        res.body.should.have.property("status").and.equal(defaultStatus);
      });
  });

  it("0040: should be able to make published data public", async () => {
    return request(appUrl)
      .post("/api/v4/PublishedData/" + doi + "/publish")
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.EntryCreatedStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.property("status").and.equal("public");
      });
  });

  it("0080: adds a new nonpublic dataset", async () => {
    return request(appUrl)
      .post("/api/v3/Datasets")
      .send(nonpublictestdataset)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.EntryCreatedStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.property("isPublished").and.equal(false);
        res.body.should.have.property("pid").and.be.string;
        res.body.should.have.property("datasetName").and.be.string;
        pidnonpublic = encodeURIComponent(res.body["pid"]);
      });
  });

  it("0090: should not be able to delete published data in amended state", async () => {
    return request(appUrl)
      .delete("/api/v4/PublishedData/" + doi)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenArchiveManager}` })
      .expect(TestData.BadRequestStatusCode)
      .expect("Content-Type", /json/);
  });

  it("0100: should fetch this new dataset", async () => {
    return request(appUrl)
      .get("/api/v3/Datasets/" + pid)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.SuccessfulGetStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.property("isPublished").and.equal(true);
      });
  });

  it("0110: should fetch the non public dataset as ingestor", async () => {
    return request(appUrl)
      .get("/api/v3/Datasets/" + pidnonpublic)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.SuccessfulGetStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.property("isPublished").and.equal(false);
      });
  });

  it("0120: adds a new origDatablock", async () => {
    return request(appUrl)
      .post("/api/v4/OrigDatablocks")
      .send(origDataBlock)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.EntryCreatedStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.property("size").and.equal(41780189);
        res.body.should.have.property("id").and.be.string;
        idOrigDatablock = res.body["id"];
      });
  });

  it("0130: should add a new attachment to this dataset", async () => {
    const testAttachment = {
      thumbnail: "data/abc123",
      caption: "Some caption",
      datasetId: decodeURIComponent(pid),
      ownerGroup: testdataset.ownerGroup,
      accessGroups: ["loki", "odin"],
    };
    return request(appUrl)
      .post("/api/v3/Datasets/" + pid + "/attachments")
      .send(testAttachment)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.EntryCreatedStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have
          .property("thumbnail")
          .and.equal(testAttachment.thumbnail);
        res.body.should.have
          .property("caption")
          .and.equal(testAttachment.caption);
        res.body.should.have
          .property("ownerGroup")
          .and.equal(testAttachment.ownerGroup);
        res.body.should.have.property("accessGroups");
        res.body.should.have.property("createdBy");
        res.body.should.have.property("updatedBy").and.be.string;
        res.body.should.have.property("createdAt");
        res.body.should.have.property("id").and.be.string;
        res.body.should.have
          .property("datasetId")
          .and.equal(testAttachment.datasetId);
        attachmentId = res.body["id"];
      });
  });

  // NOTE: Getting dataset attachment by id is missing but we modify the test little bit and check if created attachment is part of the array of attachments returned by /datasets/{id}/attachments
  it("0140: should fetch this dataset attachment", async () => {
    return request(appUrl)
      .get("/api/v3/Datasets/" + pid + "/attachments")
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.SuccessfulGetStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.length(1);
        res.body[0].should.have.property("id").and.equal(attachmentId);
      });
  });

  it("0150: should fetch some published datasets anonymously", async () => {
    var fields = {
      ownerGroup: ["p13388"],
    };
    var limits = {
      skip: 0,
      limit: 2,
    };
    return request(appUrl)
      .get(
        "/api/v3/Datasets/fullquery" +
          "?fields=" +
          encodeURIComponent(JSON.stringify(fields)) +
          "&limits=" +
          encodeURIComponent(JSON.stringify(limits)),
      )
      .set("Accept", "application/json")
      .expect(TestData.SuccessfulGetStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body[0].should.have.property("isPublished").and.equal(true);
      });
  });

  it("0160: should fail to fetch non-public dataset anonymously", async () => {
    var fields = {
      ownerGroup: [nonpublictestdataset.ownerGroup],
    };
    var limits = {
      skip: 0,
      limit: 2,
    };
    return request(appUrl)
      .get(
        "/api/v3/Datasets/fullquery" +
          "?fields=" +
          encodeURIComponent(JSON.stringify(fields)) +
          "&limits=" +
          encodeURIComponent(JSON.stringify(limits)),
      )
      .set("Accept", "application/json")
      .expect(TestData.SuccessfulGetStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.be.instanceof(Array).and.to.have.length(0);
      });
  });

  it("0170: should fetch one dataset including related data anonymously", async () => {
    var limits = {
      skip: 0,
      limit: 2,
    };
    var filter = {
      where: {
        ownerGroup: "p13388",
      },
      include: [
        {
          relation: "origdatablocks",
        },
        {
          relation: "datablocks",
        },
        {
          relation: "attachments",
        },
      ],
    };

    return request(appUrl)
      .get(
        "/api/v3/Datasets/findOne" +
          "?filter=" +
          encodeURIComponent(JSON.stringify(filter)) +
          "&limits=" +
          encodeURIComponent(JSON.stringify(limits)),
      )
      .set("Accept", "application/json")
      .expect(TestData.SuccessfulGetStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.origdatablocks[0].should.have
          .property("ownerGroup")
          .and.equal("p13388");
      });
  });

  it("0180: should delete this dataset attachment", async () => {
    return request(appUrl)
      .delete("/api/v3/Datasets/" + pid + "/attachments/" + attachmentId)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenAdminIngestor}` })
      .expect(TestData.SuccessfulDeleteStatusCode);
  });

  it("0190: should delete a OrigDatablock", async () => {
    return request(appUrl)
      .delete("/api/v4/OrigDatablocks/" + idOrigDatablock)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenArchiveManager}` })
      .expect(TestData.SuccessfulDeleteStatusCode)
      .expect("Content-Type", /json/)
      .then((res) => {
        res.body.should.have.property("id").and.equal(idOrigDatablock);
      });
  });

  it("0200: should delete the nonpublic dataset", async () => {
    return request(appUrl)
      .delete("/api/v3/Datasets/" + pidnonpublic)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenArchiveManager}` })
      .expect(TestData.SuccessfulDeleteStatusCode)
      .expect("Content-Type", /json/);
  });

  it("0210: should delete this dataset", async () => {
    return request(appUrl)
      .delete("/api/v3/Datasets/" + pid)
      .set("Accept", "application/json")
      .set({ Authorization: `Bearer ${accessTokenArchiveManager}` })
      .expect(TestData.SuccessfulDeleteStatusCode)
      .expect("Content-Type", /json/);
  });

  it("0220: should return 404", async () => {
    return request(appUrl)
      .get("/api/v4/PublishedData/non-existing-id")
      .set("Accept", "application/json")
      .expect(TestData.NotFoundStatusCode)
      .expect("Content-Type", /json/);
  });
});
